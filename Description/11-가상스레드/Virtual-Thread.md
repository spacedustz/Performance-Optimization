## 📚 Virtual Thread

JDK에 정식 도입된 Virtual 스레드는 기존의 KLT(kernel-level 스레드)와 ULT(user-level 스레드)를 1:1 매핑하여 사용하는 JVM의 스레드 모델을 개선한, 

여러 개의 가상 스레드를 하나의 네이티브 스레드에 할당하여 사용하는 모델이며, 경량 스레드로, JDK 21의 일부로 처음 공개 되었습니다. 

가상 스레드는 OS 스레드에 비해 매우 적은 자원을 사용하여 수천 개의 스레드를 효율적으로 실행할 수 있도록 설계되었고,

이를 통해 고성능 서버 애플리케이션이 더 높은 동시성을 쉽게 구현할 수 있으며, 전통적인 스레드 풀의 복잡한 설정 없이도 많은 작업을 동시에 처리할 수 있습니다.

---

## 📚 Java Thread와 OS Thread와의 관계

**Java의 Thread 클래스**

Java에서 생성되는 스레드는 OS 스레드와 밀접하게 연결됩니다. 

Thread 클래스의 `start()` 메서드를 호출하면, JVM은 새로운 OS 스레드를 생성하도록 요청하며, 이 스레드에 특정 크기의 스택 공간이 할당되고, 이 공간은 스레드가 실행하는 코드와 로컬 변수를 저장하는 데 사용됩니다.

Java의 기본 스레드는 OS 스레드를 감싸고 있으며, JVM 내의 각 스레드는 OS 스레드와 1:1로 매핑됩니다. 

이러한 설계는 OS가 CPU 스케줄링과 스레드 실행을 직접 관리하게 하지만, OS 스레드 자원이 제한되어 있어 무거운 작업에 부담이 될 수 있습니다.

<br>

**Virtual Thread**

Java의 가상 스레드는 기존의 스레드처럼 start()나 run() 메서드를 통해 시작할 코드를 가지고 있지만, OS 스레드와는 달리 완전히 JVM에서 관리됩니다. 따라서 OS는 가상 스레드의 존재를 인지하지 못하며, 가상 스레드는 필요 없어지면 GC(Garbage Collection)에 의해 자동으로 정리됩니다.

이러한 구조 덕분에 가상 스레드는 생성과 관리에 드는 비용이 매우 적고, 대량으로 효율적으로 생성할 수 있습니다.

가상 스레드의 실행 방식
가상 스레드가 실행될 때, JVM은 내부에 작은 스레드 풀을 사용하여 가상 스레드를 마운트합니다. 이 스레드 풀에 포함된 실제 OS 스레드들은 캐리어 스레드(Carrier Thread)라고 불리며, 가상 스레드를 실행시키기 위한 자원으로 사용됩니다. 가상 스레드가 끝나면 캐리어 스레드에서 마운트가 해제되고, 해제된 캐리어 스레드는 다음 가상 스레드를 실행할 준비를 합니다. 마운트가 해제된 가상 스레드는 필요 시 GC에 의해 제거됩니다.

일시 정지와 스냅샷 저장
특정 상황에서 가상 스레드가 실행을 잠시 멈춰야 한다면, JVM은 캐리어 스레드에서 가상 스레드를 마운트 해제하고 그 상태를 힙 메모리에 저장합니다. 이 저장된 상태에는 명령 포인터와 캐리어 스레드의 스택 상태가 포함되며, 이를 스냅샷이라고 합니다.

이후 가상 스레드가 재개될 때, JVM은 스냅샷을 기반으로 캐리어 스레드의 스택 메모리를 복원하여 중단된 시점에서 이어서 실행하게 됩니다.

개발자와 JVM의 역할
가상 스레드와 캐리어 스레드는 JVM이 자동으로 관리하므로, 개발자는 별도로 제어할 필요가 없습니다. 이로 인해 가상 스레드는 복잡한 설정 없이도 대량의 스레드를 쉽게 활용할 수 있는 유연성을 제공합니다.

가상 스레드의 이러한 특성 덕분에 Java 애플리케이션은 높은 동시성을 가볍게 구현할 수 있게 되었습니다.


---

## 📚 Virtual 스레드 동작 과정