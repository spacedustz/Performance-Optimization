## 📚 Lock-Free Algorithm

이번에 배운 Lock-Free 알고리즘은 동시성 제어에서 중요한 개념중 하나입니다.

주로 멀티스레딩 환경에서 Lock을 사용하지 않고도 Shared Resource에 안전하게 접근하거나 제어할 수 있는 방법입니다.

그럼 왜 Lock이 있는데 Lock을 사용하지 않는지, 왜 위험한지 공부할겸 이유를 다시 적어보겠습니다.

<br>

### Lock 사용 시 문제점

**Slow Critical Section**

- 같은 Lock 을 사용하는 멀티 스레드가 있는 경우
- 내용이 많거나 긴 임계영역은 처음 스레드에게 Lock을 주고 다른 스레드를 계속 대기하게 합니다.
- 그 스레드 수가 많다면 다른 모든 스레드는 작업을 하지 못할 겁니다.

<br>

**Priority Inversion**

- 리소스 하나와 그 리소스의 Lock을 공유하는 스레드가 2개일때 생기는 문제입니다.
- 예를 들어 백그라운드 문서 저장 스레드와 UI 스레드 중 UI가 우선순위가 높을 경우입니다.
- 만약 Priority가 낮은 스레드가 Lock을 얻고 OS는 우선순위가 높은 스레드를 계속 스케줄링 하려고 하지만,
- 우선순위가 낮은 스레드가 Lock을 Release 할 때까지 계속 대기하게 되서 우선순위가 뒤바뀌는 것처럼 보이는 현상입니다.
- 이 문제는 특히 실시간 시스템(예: 게임 UI나 사용자 인터페이스)에서 문제가 되는데, 사용자는 우선순위가 높은 스레드가 응답하지 않기 때문에 시스템이 멈춘 것처럼 느끼게 됩니다.

<br>

**Kill Tolerance**

- 우선순위 역전이나 느린 임계영역보다 훨씬 치명적인건 Lock을 가진 스레드가 그냥 죽거나 인터럽트 될 때 입니다.
- Unlock 하는걸 깜빡 하는 경우도 포함입니다.
- 그 결과는 모든 다른 스레드가 영원히 정체되고 데드락처럼 회복되지 않을겁니다.
- 그래서 항상 중요한 영역에 타임아웃을 가진 `tryLock()`을 사용해 복잡한 코드를 사용하도록 강제됩니다.

<br>

**Performance**

- Lock을 얻기위한 스레드 간 다툼이 발생하는 문제인데 이때 성능 오버헤드가 있습니다.
- 스레드 A,B가 있다고 할떄 A가 Lock을 획득하면 B가 계속 가지려 하고 Block 됩니다.
- 이떄 B에서 다른 스레드로의 컨텍스트 스위칭이 일어나고 Lock이 Release 될 떄 다시 B를 가져오는 오버헤드가 생깁니다.
- 이런 오버헤드는 대부분의 어플리케이션에서는 감지하지 못하지만, 밀리초보다 짧은 지연 시간으로 연산하는 고속 거래시스템에서는 고래해야 할 중요 요소입니다.

---

## 📚 Atomic

